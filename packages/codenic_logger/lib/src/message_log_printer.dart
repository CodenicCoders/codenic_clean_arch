import 'dart:convert';
import 'dart:math';

import 'package:codenic_logger/src/map_extension.dart';
import 'package:codenic_logger/src/message_log.dart';
import 'package:logger/logger.dart';

/// {@template MessageLogPrinter}
///
/// An extension of [PrettyPrinter] that displays the content of a [MessageLog]
/// and prevents long texts from being truncated.
///
/// Output looks like this:
/// ```bash
/// ─ID────────────────────────
///  Identifier
/// ─Time──────────────────────
///  Time
/// ─Error─────────────────────
///  Error info
/// ─Stacktrace────────────────
///  Method stack history
/// ─Message───────────────────
///  Message
/// ─Data──────────────────────
///  Data
/// ──────────────────────────–
/// ```
///
/// {@endtemplate}
class MessageLogPrinter extends PrettyPrinter {
  /// {@macro MessageLogPrinter}
  MessageLogPrinter({
    super.printTime = true,
    this.splitTextByCharacterCount = 1024,
    super.stackTraceBeginIndex,
    super.methodCount,
    super.errorMethodCount,
    super.lineLength,
    super.colors,
    super.printEmojis,
    super.excludeBox,
    super.noBoxingByDefault,
    List<RegExp>? stackTraceBlocklist,
  }) : stackTraceBlocklist = stackTraceBlocklist ?? [] {
    // Translate excludeBox map (constant if default) to includeBox map with
    // all Level enum possibilities
    _includeBox = {
      ...Map.fromEntries(
        Level.values.map((level) => MapEntry(level, !noBoxingByDefault)),
      ),
      ...Map.fromEntries(
        excludeBox.entries.map((entry) => MapEntry(entry.key, !entry.value)),
      ),
    };
  }

  /// A collection of regex for excluding stack trace lines from being shown
  /// in the output.
  ///
  /// For example, to exclude all lines that contain the word "logger" from the
  /// stack trace, use:
  ///
  /// ```dart
  /// stackTraceBlocklist: [RegExp(r'logger')]
  /// ```
  final List<RegExp> stackTraceBlocklist;

  /// The maximum number of characters in a single line of the output.
  ///
  /// If the text is longer than this value, it will be split into multiple
  /// lines.
  ///
  /// If `null`, the text will not be split.
  ///
  /// This is useful for preventing Android/IOS log messages from being
  /// truncated.
  ///
  final int? splitTextByCharacterCount;

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex =
      RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/logger.dart
  static final _browserStackTraceRegex =
      RegExp(r'^(?:package:)?(dart:[^\s]+|[^\s]+)');

  /// Contains the parsed rules resulting from [excludeBox] and
  /// [noBoxingByDefault].
  ///
  /// See [PrettyPrinter] `_includeBox` private variable for more information.
  late final Map<Level, bool> _includeBox;

  @override
  List<String> log(LogEvent event) {
    String? stackTraceFormatted;

    if (event.stackTrace == null) {
      if (methodCount == null || methodCount! > 0) {
        stackTraceFormatted = formatStackTrace(StackTrace.current, methodCount);
      }
    } else if (errorMethodCount == null || errorMethodCount! > 0) {
      stackTraceFormatted =
          formatStackTrace(event.stackTrace, errorMethodCount);
    }

    return _formatAndPrint(
      event.level,
      event.message as MessageLog,
      dateTimeFormat(event.time),
      event.error?.toString(),
      stackTraceFormatted,
    );
  }

  @override
  String? formatStackTrace(StackTrace? stackTrace, int? methodCount) {
    final lines = stackTrace
        .toString()
        .split('\n')
        .where(
          (line) =>
              !_discardBlocklistedStackTraceLine(line) &&
              !_discardDeviceStackTraceLine(line) &&
              !_discardWebStacktraceLine(line) &&
              !_discardBrowserStacktraceLine(line) &&
              line.isNotEmpty,
        )
        .toList();

    final formatted = <String>[];

    final stackTraceLength =
        (methodCount != null ? min(lines.length, methodCount) : lines.length);

    for (var count = 0; count < stackTraceLength; count++) {
      final line = lines[count];
      if (count < stackTraceBeginIndex) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardBlocklistedStackTraceLine(String line) {
    if (stackTraceBlocklist.isEmpty) {
      return false;
    }

    for (final stackTraceRegex in stackTraceBlocklist) {
      if (stackTraceRegex.hasMatch(line)) {
        return true;
      }
    }

    return false;
  }

  bool _discardDeviceStackTraceLine(String line) {
    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(2)!.startsWith('package:logger') ||
        match.group(2)!.startsWith('package:codenic_logger');
  }

  bool _discardWebStacktraceLine(String line) {
    final match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('packages/logger') ||
        match.group(1)!.startsWith('packages/codenic_logger') ||
        match.group(1)!.startsWith('dart-sdk/lib');
  }

  bool _discardBrowserStacktraceLine(String line) {
    final match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }

    return match.group(1)!.startsWith('package:logger') ||
        match.group(1)!.startsWith('package:codenic_logger') ||
        match.group(1)!.startsWith('dart:');
  }

  AnsiColor _getLevelColor(Level level) {
    if (!colors) {
      return const AnsiColor.none();
    }

    return levelColors?[level] ??
        PrettyPrinter.defaultLevelColors[level] ??
        const AnsiColor.none();
  }

  String _getEmoji(Level level) {
    if (!printEmojis) {
      return '';
    }

    final emoji =
        levelEmojis?[level] ?? PrettyPrinter.defaultLevelEmojis[level];

    return '$emoji ';
  }

  List<String> _formatAndPrint(
    Level level,
    MessageLog messageLog,
    String? time,
    String? error,
    String? stacktrace,
  ) {
    // This code is non trivial and a type annotation here helps understanding.
    final buffer = <String>[];

    final color = _getLevelColor(level);

    if (_includeBox[level]!) buffer.add(color(_createDivider('ID')));

    final emoji = _getEmoji(level);

    buffer.add(color('$emoji${messageLog.id}'));

    if (time != null) {
      if (_includeBox[level]!) buffer.add(color(_createDivider('Time')));
      buffer.add(color(time));
    }

    if (error != null) {
      if (_includeBox[level]!) buffer.add(color(_createDivider('Error')));

      for (final line in error.split('\n')) {
        buffer.add(color(line));
      }
    }

    if (stacktrace != null) {
      if (_includeBox[level]!) buffer.add(color(_createDivider('Stacktrace')));
      for (final line in stacktrace.split('\n')) {
        buffer.add(color(line));
      }
    }

    final message = messageLog.message;

    if (message != null) {
      if (_includeBox[level]!) buffer.add(color(_createDivider('Message')));
      _trySplitText(message).forEach((text) => buffer.add(color(text)));
    }

    if (messageLog.data.isNotEmpty) {
      if (_includeBox[level]!) buffer.add(color(_createDivider('Data')));

      final data = jsonEncode(messageLog.data.toJsonEncodable());
      _trySplitText(data).forEach((text) => buffer.add(color(text)));
    }

    if (_includeBox[level]!) buffer.add(color(_createDivider()));

    return buffer;
  }

  String _createDivider([String? title]) {
    final titleLength = title?.length ?? 0;

    return '─${title ?? ''}${'-' * max(lineLength - titleLength - 1, 0)}';
  }

  /// Flutter truncates
  Iterable<String> _trySplitText(String text) {
    if (splitTextByCharacterCount == null) return [text];

    return RegExp('.{1,$splitTextByCharacterCount}')
        .allMatches(text)
        .map((e) => e.group(0) ?? '');
  }

  // coverage:ignore-start
  /// Creates a new [MessageLogPrinter] with the values replaced by the
  /// non-null.
  MessageLogPrinter copyWith({
    int? stackTraceBeginIndex,
    int? methodCount,
    int? errorMethodCount,
    int? lineLength,
    bool? colors,
    bool? printEmojis,
    Map<Level, bool>? excludeBox,
    bool? noBoxingByDefault,
    List<RegExp>? stackTraceBlocklist,
  }) {
    return MessageLogPrinter(
      stackTraceBeginIndex: stackTraceBeginIndex ?? this.stackTraceBeginIndex,
      methodCount: methodCount ?? this.methodCount,
      errorMethodCount: errorMethodCount ?? this.errorMethodCount,
      lineLength: lineLength ?? this.lineLength,
      colors: colors ?? this.colors,
      printEmojis: printEmojis ?? this.printEmojis,
      excludeBox: excludeBox ?? this.excludeBox,
      noBoxingByDefault: noBoxingByDefault ?? this.noBoxingByDefault,
      stackTraceBlocklist: stackTraceBlocklist ?? this.stackTraceBlocklist,
    );
  }
  // coverage:ignore-end
}
